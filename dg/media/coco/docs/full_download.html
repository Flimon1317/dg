<!DOCTYPE html>

<html>
<head>
  <title>full_download.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
      <ul id="jump_to">
        <li>
          <a class="large" href="javascript:void(0);">Jump To &hellip;</a>
          <a class="small" href="javascript:void(0);">+</a>
          <div id="jump_wrapper">
          <div id="jump_page">
            
              
              <a class="source" href="app.html">
                app.js
              </a>
            
              
              <a class="source" href="auth.html">
                auth.js
              </a>
            
              
              <a class="source" href="auth_offline_backend.html">
                auth_offline_backend.js
              </a>
            
              
              <a class="source" href="upload_collection.html">
                upload_collection.js
              </a>
            
              
              <a class="source" href="configs.html">
                configs.js
              </a>
            
              
              <a class="source" href="convert_namespace.html">
                convert_namespace.js
              </a>
            
              
              <a class="source" href="denormalize.html">
                denormalize.js
              </a>
            
              
              <a class="source" href="indexeddb_backbone_config.html">
                indexeddb_backbone_config.js
              </a>
            
              
              <a class="source" href="main.html">
                main.js
              </a>
            
              
              <a class="source" href="user_model.html">
                user_model.js
              </a>
            
              
              <a class="source" href="offline_utils.html">
                offline_utils.js
              </a>
            
              
              <a class="source" href="online_utils.html">
                online_utils.js
              </a>
            
              
              <a class="source" href="router.html">
                router.js
              </a>
            
              
              <a class="source" href="user_initialize.html">
                user_initialize.js
              </a>
            
              
              <a class="source" href="app_layout.html">
                app_layout.js
              </a>
            
              
              <a class="source" href="dashboard.html">
                dashboard.js
              </a>
            
              
              <a class="source" href="form.html">
                form.js
              </a>
            
              
              <a class="source" href="form_controller.html">
                form_controller.js
              </a>
            
              
              <a class="source" href="full_download.html">
                full_download.js
              </a>
            
              
              <a class="source" href="incremental_download.html">
                incremental_download.js
              </a>
            
              
              <a class="source" href="list.html">
                list.js
              </a>
            
              
              <a class="source" href="login.html">
                login.js
              </a>
            
              
              <a class="source" href="notification.html">
                notification.js
              </a>
            
              
              <a class="source" href="status.html">
                status.js
              </a>
            
              
              <a class="source" href="upload.html">
                upload.js
              </a>
            
          </div>
        </li>
      </ul>
    
    <ul class="sections">
        
          <li id="title">
              <div class="annotation">
                  <h1>full_download.js</h1>
              </div>
          </li>
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre><span class="comment">/* Performs the full database download. For each table listed in configs, creates chunked requests to fetch data 
from server and saves it in offline db. To make it resumable, it does not clear the database before starting downloading. 
For each chunk request created, it checks if that chunk request was already downloaded by looking into the meta data store 
in offline DB. 
Since it continues from the present state of database found - In order to do a fresh download, there needs to be some 
external code which flushes the database before calling this module.
*/</span>
define([
  <span class="string">'jquery'</span>,
  <span class="string">'underscore'</span>,
  <span class="string">'layoutmanager'</span>,
  <span class="string">'indexeddb_backbone_config'</span>,
  <span class="string">'configs'</span>,
  <span class="string">'offline_utils'</span>,
  <span class="string">'bootstrapjs'</span>                            
], <span class="keyword">function</span>(jquery,underscore,layoutmanager,indexeddb, all_configs, Offline){</pre></div></div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p>clears objectstores - meta_data, uploadqueue, all config-defined objectstores
refills all config-defined objectstores
fills the last_downlaoded timestamp in meta_data</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">var</span> FullDownloadView = Backbone.Layout.extend({
        template: <span class="string">"#download_template"</span>,
        
        internet_connected : <span class="keyword">function</span>(){
            <span class="keyword">return</span> navigator.onLine;
        },
        
        initialize: <span class="keyword">function</span>(){
            _.bindAll(<span class="keyword">this</span>);
        },
        
        serialize: <span class="keyword">function</span>(){
            <span class="keyword">return</span> {
                all_configs: all_configs
            }
        },
        
        events:{
            <span class="string">'click #stop_full_download'</span>: <span class="string">'stop_download'</span>
        },
        
        stop_download: <span class="keyword">function</span>(){
            console.log(<span class="string">"stopping download"</span>);
            <span class="keyword">this</span>.remove_ui();
            <span class="keyword">this</span>.full_download_dfd.reject(<span class="string">"User stopped download"</span>);
            $.each(<span class="keyword">this</span>.network_requests, <span class="keyword">function</span>(index, xhr){
                xhr.abort();
            });
        },

        <span class="comment">/* 
        TODO Checks if there is already a full downloaded database, alert user that this db should be removed before proceeding 
        Checks internet connectivity
        Initializes UI and objects used to update status. 
        Fetches the full_download_info objectStore to resume download, if that's the case
        Stores the start time for download
        */</span>    
        initialize_download: <span class="keyword">function</span>(){</pre></div></div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <p>Django complains when Z is present in timestamp bcoz timezone capab is off</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="keyword">this</span>.start_time = <span class="keyword">new</span> Date().toJSON().replace(<span class="string">"Z"</span>, <span class="string">""</span>);
            <span class="keyword">if</span>(!<span class="keyword">this</span>.internet_connected())
            {
                dfd.reject(<span class="string">"Can't download database. Internet is not connected"</span>);
                <span class="keyword">return</span> dfd;
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <p>intialize UI objects</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="keyword">this</span>.$(<span class="string">'#full_download_modal'</span>).modal({
                keyboard: <span class="literal">false</span>,
                backdrop: <span class="string">"static"</span>,
            });
            <span class="keyword">this</span>.$(<span class="string">'#full_download_modal'</span>).modal(<span class="string">'show'</span>);
            <span class="keyword">this</span>.download_status = {};</pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>///////////////////////////////////////</p>

            </div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p>every request made to server will be stored in this, - to abort if user chooses to stop download</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="keyword">this</span>.network_requests = [];</pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <p>///////////////////////////////////////</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            
            <span class="keyword">var</span> already_downloaded_chunks_dfd = <span class="keyword">this</span>.get_already_downloaded_chunks();
            <span class="keyword">var</span> start_time_dfd = <span class="keyword">this</span>.fetch_or_set_download_start_time();
            
            <span class="keyword">return</span> $.when.apply($, [already_downloaded_chunks_dfd, start_time_dfd]);
        },</pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <p>fetching the full_download_info collection to be used for resuming download</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        get_already_downloaded_chunks: <span class="keyword">function</span>(){
            <span class="keyword">var</span> dfd = <span class="keyword">new</span> $.Deferred();
            <span class="keyword">var</span> that = <span class="keyword">this</span>;
            Offline.fetch_collection(<span class="string">"full_download_info"</span>)
                .done(<span class="keyword">function</span>(coll){
                    that.full_download_info_coll = coll;
                    dfd.resolve();
                })
                .fail(<span class="keyword">function</span>(error){
                    dfd.reject(error);
                });
            <span class="keyword">return</span> dfd; 
           
        },</pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p>if download resumes then get the original start time other wise record current time as start time</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        fetch_or_set_download_start_time: <span class="keyword">function</span>(){
            <span class="keyword">var</span> dfd = <span class="keyword">new</span> $.Deferred();
            <span class="keyword">var</span> that = <span class="keyword">this</span>;
            Offline.fetch_object(<span class="string">"meta_data"</span>, <span class="string">"key"</span>, <span class="string">"last_full_download_start"</span>)
                .fail(<span class="keyword">function</span>(model, error){
                    that.set_timestamp(model, that.start_time)
                        .done(<span class="keyword">function</span>(){
                            dfd.resolve();
                        })
                        .fail(<span class="keyword">function</span>(error){
                            dfd.reject(error);
                        });
                })
                .done(<span class="keyword">function</span>(model){
                    that.start_time = model.get(<span class="string">"timestamp"</span>);    
                    dfd.resolve();
                });
            <span class="keyword">return</span> dfd;    
        },

        set_timestamp: <span class="keyword">function</span>(model, timestamp){
            model.set(<span class="string">'timestamp'</span>,timestamp);
            <span class="keyword">return</span> model.save();    <span class="comment">//returns a promise</span>
        },
        
        remove_ui: <span class="keyword">function</span>(){</pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <p>calling remove without hiding modal causes modal&#39;s backdrop to remain</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="keyword">this</span>.$(<span class="string">'#full_download_modal'</span>).modal(<span class="string">'hide'</span>); 
            <span class="keyword">this</span>.remove();
        },
        
        start_full_download: <span class="keyword">function</span>(){
            <span class="keyword">this</span>.full_download_dfd = <span class="keyword">new</span> $.Deferred();
            <span class="keyword">var</span> that = <span class="keyword">this</span>;
            <span class="keyword">this</span>.initialize_download()
                .done(<span class="keyword">function</span>(){
                    that.iterate_object_stores()
                        .done(<span class="keyword">function</span>(){
                            that.finish_download()
                                .done(<span class="keyword">function</span>(){
                                    that.call_after_download()
                                        .done(<span class="keyword">function</span>(){
                                            that.remove_ui();
                                            that.full_download_dfd.resolve();
                                        })
                                        .fail(<span class="keyword">function</span>(error){
                                            that.remove_ui();
                                            that.full_download_dfd.reject(error);
                                        });
                                })
                                .fail(<span class="keyword">function</span>(error){
                                    that.remove_ui();
                                    that.full_download_dfd.reject(error);
                                });
                        })
                        .fail(<span class="keyword">function</span>(error){
                            that.remove_ui();
                            that.full_download_dfd.reject(error);
                        })
                })
                .fail(<span class="keyword">function</span>(error){
                    that.remove_ui();
                    that.full_download_dfd.reject(error);
                });
                
            <span class="keyword">return</span> <span class="keyword">this</span>.full_download_dfd;    
        },
        
        call_after_download: <span class="keyword">function</span>(){
            <span class="keyword">if</span>(all_configs.misc.afterFullDownload)
                <span class="keyword">return</span> all_configs.misc.afterFullDownload(<span class="keyword">this</span>.start_time, <span class="keyword">this</span>.download_status) <span class="comment">//must return a promise</span>
            <span class="keyword">else</span>
                <span class="keyword">return</span> <span class="keyword">new</span> $.Deferred().resolve();
        },
        
        <span class="comment">/* Starts download for all tables defined in config object. Rejects when any of them fails, Resolves when all are 
        successfully downloaded*/</span>
        iterate_object_stores: <span class="keyword">function</span>(){
            <span class="keyword">var</span> dfd = <span class="keyword">new</span> $.Deferred();
            <span class="keyword">this</span>.$(<span class="string">'#stop_full_download'</span>).prop(<span class="string">"disabled"</span>, <span class="literal">false</span>);
            <span class="keyword">var</span> entity_dfds = [];
            
            <span class="keyword">for</span> (<span class="keyword">var</span> member <span class="keyword">in</span> all_configs) {
                <span class="keyword">if</span>(member == <span class="string">"misc"</span>)
                    <span class="keyword">continue</span>;
                <span class="keyword">this</span>.download_status[member] = {
                    total:<span class="literal">null</span>,
                    downloaded:<span class="number">0</span>
                };
                <span class="keyword">var</span> entity_dfd = <span class="keyword">this</span>.start_full_download_for_entity(all_configs[member][<span class="string">"entity_name"</span>]);
                entity_dfds.push(entity_dfd);
            }
            
            $.when.apply($, entity_dfds)
                .done(<span class="keyword">function</span>(){
                    dfd.resolve();
                })
                .fail(<span class="keyword">function</span>(error){
                    dfd.reject(error);
                });
            <span class="keyword">return</span> dfd;    
        },
        
        update_pb_ui: <span class="keyword">function</span>() {</pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <p>can&#39;t show progress bar untill total num of objects is known</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="keyword">var</span> ready_to_show = <span class="literal">true</span>; 
            <span class="keyword">var</span> total = <span class="number">0</span>;
            <span class="keyword">var</span> downloaded = <span class="number">0</span>;
            _.each(<span class="keyword">this</span>.download_status, <span class="keyword">function</span>(status, entity){</pre></div></div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <p>if total objects for any entity are not yet known, then can&#39;t show the progress</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="keyword">if</span>(status.total==<span class="literal">null</span>)
                {
                    ready_to_show = <span class="literal">false</span>;
                    <span class="keyword">return</span>;    
                }
                <span class="keyword">else</span>
                {
                    total += status.total;
                    downloaded += status.downloaded;
                }
            });
            
            <span class="keyword">if</span>(!ready_to_show)
                <span class="keyword">return</span>;

            <span class="keyword">var</span> percent_complete = (downloaded/total)*<span class="number">100</span> +<span class="string">"%"</span>;
            $(<span class="string">'#pbar'</span>).css(<span class="string">"width"</span>, percent_complete);
        },
        
        update_status_ui: <span class="keyword">function</span>(entity_name){
            <span class="keyword">var</span> downloaded = <span class="keyword">this</span>.download_status[entity_name].downloaded;
            <span class="keyword">var</span> total = <span class="keyword">this</span>.download_status[entity_name].total;
            <span class="keyword">var</span> s_text = <span class="string">"In Progress"</span>;
            <span class="keyword">if</span>(downloaded&gt;=total)
                s_text = <span class="string">"Done"</span>;
            <span class="keyword">var</span> s_num = String(downloaded)+<span class="string">"/"</span>+String(total);    
                
            <span class="keyword">this</span>.$(<span class="string">'#'</span>+entity_name).find(<span class="string">'.status_text'</span>).html(s_text);
            <span class="keyword">this</span>.$(<span class="string">'#'</span>+entity_name).find(<span class="string">'.status_numbers'</span>).html(s_num);
        },
        
        start_full_download_for_entity: <span class="keyword">function</span>(entity_name){
            <span class="keyword">var</span> dfd = <span class="keyword">new</span> $.Deferred();
            <span class="keyword">var</span> that = <span class="keyword">this</span>;
            that.get_num_of_objects_to_download(entity_name)
                .done(<span class="keyword">function</span>(total_num_objects){
                    that.chunk_it_fetch_it_save_it(entity_name, total_num_objects)
                        .done(<span class="keyword">function</span>(){
                            console.log(<span class="string">"FINISHED DOWNLOADING - "</span> + entity_name);
                            <span class="keyword">return</span> dfd.resolve();
                        })
                        .fail(<span class="keyword">function</span>(error){
                            <span class="keyword">return</span> dfd.reject(error);
                        });
                })
                .fail(<span class="keyword">function</span>(){
                    console.log(<span class="string">"DASHBOARD:DOWNLOAD:UnexpectedError: Error fetching num of objects to download for - "</span> + entity_name);
                    alert(<span class="string">"DASHBOARD:DOWNLOAD:UnexpectedError: Error fetching num of objects to download for - "</span> + entity_name);
                    <span class="keyword">return</span> dfd.reject(<span class="string">"Failed to fetch num of objects for - "</span>+entity_name);
                });
            <span class="keyword">return</span> dfd;
        },
        
        get_num_of_objects_to_download: <span class="keyword">function</span>(entity_name){
            <span class="keyword">var</span> dfd = <span class="keyword">new</span> $.Deferred();
            console.log(<span class="string">"DASHBOARD:DOWNLOAD: Fetching num of objects to download for - "</span>+entity_name);
            <span class="keyword">var</span> xhr = $.get(all_configs[entity_name].rest_api_url, {limit:<span class="number">1</span>,offset:<span class="number">0</span>}, <span class="keyword">function</span>(data){
                <span class="keyword">if</span>(data &amp;&amp; data.meta)
                    <span class="keyword">return</span> dfd.resolve(data.meta.total_count);
                <span class="keyword">else</span>
                    <span class="keyword">return</span> dfd.reject();
            });
            <span class="keyword">this</span>.network_requests.push(xhr);
            <span class="keyword">return</span> dfd;
        },
        
        update_download_status: <span class="keyword">function</span>(entity_name, key, increment){
            <span class="keyword">var</span> s_obj = <span class="keyword">this</span>.download_status[entity_name];
            <span class="keyword">if</span>(!s_obj[key])
                s_obj[key] = increment;
            <span class="keyword">else</span>
                s_obj[key] += increment;
                
            <span class="keyword">this</span>.update_status_ui(entity_name);
            <span class="keyword">this</span>.update_pb_ui();
                    
        },
        
        chunk_it_fetch_it_save_it: <span class="keyword">function</span>(entity_name, total_num_objects){
            <span class="keyword">var</span> dfd = <span class="keyword">new</span> $.Deferred();
            <span class="keyword">this</span>.update_download_status(entity_name, <span class="string">"total"</span>, total_num_objects);
            
            <span class="keyword">var</span> limit = <span class="number">1500</span>; <span class="comment">//default</span>
            <span class="keyword">if</span>(all_configs[entity_name].download_chunk_size)    <span class="comment">//entity specific option</span>
                limit = all_configs[entity_name].download_chunk_size;
            <span class="keyword">else</span> <span class="keyword">if</span>(all_configs.misc.download_chunk_size)    <span class="comment">// global option</span>
                limit = all_configs.misc.download_chunk_size;
            <span class="keyword">var</span> num_chunks = Math.ceil(total_num_objects/ limit); 
            console.log(<span class="string">"Num of chunks for - "</span>+entity_name+<span class="string">" = "</span>+num_chunks);
            <span class="keyword">var</span> offset = <span class="number">0</span>;
            <span class="keyword">var</span> chunk_dfds = [];
            <span class="keyword">var</span> that = <span class="keyword">this</span>;
            <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;num_chunks; i++)
            {
                <span class="keyword">var</span> chunk_dfd = <span class="keyword">this</span>.process_chunk(entity_name, offset, limit);
                chunk_dfd.done(<span class="keyword">function</span>(num_objects_saved){
                    that.update_download_status(entity_name, <span class="string">"downloaded"</span>, num_objects_saved);
                });
                chunk_dfds.push(chunk_dfd);
                offset += limit;
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p>when all chunks of this entity are downloaded...</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            $.when.apply($, chunk_dfds)
                .done(<span class="keyword">function</span>(){
                    <span class="keyword">return</span> dfd.resolve();
                })
                .fail(<span class="keyword">function</span>(error){
                    <span class="keyword">return</span> dfd.reject(error);
                });
            <span class="keyword">return</span> dfd;
        },
        
        process_chunk: <span class="keyword">function</span>(entity_name, offset, limit){
            <span class="keyword">var</span> dfd = <span class="keyword">new</span> $.Deferred();
            <span class="keyword">var</span> that = <span class="keyword">this</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <p>TODO check if this chunk is already downloaded, if not call fetch_save</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="keyword">var</span> num_downloaded = <span class="keyword">this</span>.is_already_downloaded(entity_name, offset, limit);
            <span class="keyword">if</span>(num_downloaded!=-<span class="number">1</span>)
                dfd.resolve(num_downloaded);
            <span class="keyword">else</span>
            {
                <span class="keyword">this</span>.fetch_save(entity_name, offset, limit)
                    .done(<span class="keyword">function</span>(num_downloaded){
                        that.save_as_downloaded(entity_name, offset, limit, num_downloaded);
                        dfd.resolve(num_downloaded);
                    })
                    .fail(<span class="keyword">function</span>(error){
                        dfd.reject(error);
                    });
            }
            
            <span class="keyword">return</span> dfd;    
        },
        
        <span class="comment">/*checks if (entity_name, offset, limit) exists in full_download_info
        return num of objects that were downloaded if it exists, -1 otherwise*/</span>
        is_already_downloaded: <span class="keyword">function</span>(entity_name, offset, limit){
            <span class="keyword">var</span> exists = <span class="keyword">this</span>.full_download_info_coll.where({entity_name:entity_name, offset:offset, limit: limit});
            <span class="keyword">if</span>(exists.length)
            {
                console.log(<span class="string">"CHUNK ALREADY EXISTS DOWNLOADED"</span>);
                <span class="keyword">return</span> exists[<span class="number">0</span>].get(<span class="string">"num_objects_downloaded"</span>);
            }
            <span class="keyword">return</span> -<span class="number">1</span>    
        },
        
        <span class="comment">/*creates (entity_name, offset, limit, num_downloaded) object in full_download_info - which means 
        this chunk won't be downloaded again in case download interrupts and is resumed again*/</span>
        save_as_downloaded: <span class="keyword">function</span>(entity_name, offset, limit, num_downloaded){
            <span class="keyword">this</span>.full_download_info_coll.create({entity_name:entity_name, offset:offset, limit: limit, num_objects_downloaded: num_downloaded},{
                success:<span class="keyword">function</span>(model){
                    console.log(<span class="string">"CHUNK SAVED AS DOWNLOADED-"</span>+JSON.stringify(model));
                }
            });
        },
        
        fetch_save: <span class="keyword">function</span>(entity_name, offset, limit){
            <span class="keyword">var</span> dfd = <span class="keyword">new</span> $.Deferred();
            <span class="keyword">var</span> that = <span class="keyword">this</span>;
            <span class="keyword">this</span>.fetch_collection(entity_name, offset, limit)
                .done(<span class="keyword">function</span>(collection){
                    that.save_collection(entity_name, collection)
                        .done(<span class="keyword">function</span>(){
                            <span class="keyword">return</span> dfd.resolve(collection.length);    
                        })
                        .fail(<span class="keyword">function</span>(error){
                            <span class="keyword">return</span> dfd.reject(<span class="string">"DOWNLOAD: Failed to save an object of "</span>+entity_name+<span class="string">" - "</span>+error);
                        });
                })
                .fail(<span class="keyword">function</span>(){
                    console.log(<span class="string">"DASHBOARD:DOWNLOAD: error fetching collection from server"</span>);
                    <span class="keyword">return</span> dfd.reject(<span class="string">"DOWNLOAD: Failed to fetch collection for "</span>+entity_name);
                });
            <span class="keyword">return</span> dfd;    
        },
        
        fetch_collection: <span class="keyword">function</span>(entity_name, offset, limit){
            <span class="keyword">var</span> dfd = <span class="keyword">new</span> $.Deferred();
            <span class="keyword">var</span> generic_collection_online = Backbone.Collection.extend({
                url: all_configs[entity_name].rest_api_url,
                sync: Backbone.ajaxSync,
                parse: <span class="keyword">function</span>(data) {
                    <span class="keyword">return</span> data.objects;
                }
            });
            <span class="keyword">var</span> collection_online = <span class="keyword">new</span> generic_collection_online();
            <span class="keyword">var</span> xhr = collection_online.fetch({
                data: {
                    limit: limit,
                    offset: offset
                },
                success: <span class="keyword">function</span>(collection){
                    <span class="keyword">return</span> dfd.resolve(collection);
                },
                error: <span class="keyword">function</span>(){
                    <span class="keyword">return</span> dfd.reject();
                }
            });
            <span class="keyword">this</span>.network_requests.push(xhr);
            <span class="keyword">return</span> dfd;
        },
        
        save_collection: <span class="keyword">function</span>(entity_name, collection){
            <span class="keyword">var</span> dfd = <span class="keyword">new</span> $.Deferred();
            <span class="keyword">var</span> objects = collection.toJSON();
            <span class="keyword">var</span> dfds = [];
            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; objects.length; i++) {
                objects[i][<span class="string">'id'</span>] = parseInt(objects[i][<span class="string">'id'</span>]);
                objects[i][<span class="string">'online_id'</span>] = parseInt(objects[i][<span class="string">'id'</span>]);
                <span class="keyword">var</span> s_dfd = <span class="keyword">this</span>.save_object(entity_name, objects[i]);
                dfds.push(s_dfd);
            }
            $.when.apply($, dfds)
                .done(<span class="keyword">function</span>(){
                    <span class="keyword">return</span> dfd.resolve();
                })
                .fail(<span class="keyword">function</span>(error){
                    console.log(error);
                    <span class="keyword">return</span> dfd.reject();
                });
            <span class="keyword">return</span> dfd;    
        },
        
        <span class="comment">/* custom save to allow constraint error fails */</span>
        save_object: <span class="keyword">function</span>(entity_name, json){
            <span class="keyword">var</span> dfd = <span class="keyword">new</span> $.Deferred();
            <span class="keyword">var</span> model =  Offline.create_b_model(entity_name);
            model.save(json,{
                success: <span class="keyword">function</span>(){
                    <span class="keyword">return</span> dfd.resolve();
                },
                error: <span class="keyword">function</span>(model,error){
                    <span class="keyword">if</span>(error.srcElement.error.name==<span class="string">"ConstraintError"</span>)
                    {
                        <span class="keyword">return</span> dfd.resolve();
                    }
                    <span class="keyword">return</span> dfd.reject();
                }
            });
            <span class="keyword">return</span> dfd;
        },
                        
        finish_download: <span class="keyword">function</span>(){
            <span class="keyword">var</span> dfd = <span class="keyword">new</span> $.Deferred();
            console.log(<span class="string">"DASHBOARD:DOWNLOAD: In finish download"</span>);
            <span class="keyword">var</span> that = <span class="keyword">this</span>;
            that.db_downloaded();
			
            Offline.fetch_object(<span class="string">"meta_data"</span>, <span class="string">"key"</span>, <span class="string">"last_full_download"</span>)
                .done(<span class="keyword">function</span>(model){
                    that.set_timestamp(model, that.start_time)
                        .done(<span class="keyword">function</span>(){
                            dfd.resolve();
                        })
                        .fail(<span class="keyword">function</span>(error){
                            dfd.reject(error);
                        });
                })
                .fail(<span class="keyword">function</span>(model, error){
                    that.set_timestamp(model, that.start_time)
                        .done(<span class="keyword">function</span>(){
                            dfd.resolve();
                        })
                        .fail(<span class="keyword">function</span>(error){
                            dfd.reject(error);
                        });
                });
                        
            <span class="keyword">return</span> dfd;
        },

		db_downloaded: <span class="keyword">function</span>(){
			$(<span class="string">'.list_items'</span>).unbind(<span class="string">'click'</span>, <span class="literal">false</span>);
			$(<span class="string">'.list_items'</span>).removeClass(<span class="string">"disabled"</span>);
			console.log(<span class="string">"Dashboard links enabled"</span>);
			$(<span class="string">"#helptext"</span>).hide();
		}
        
                
    
          
    });
    
  <span class="keyword">return</span> FullDownloadView;
});</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
